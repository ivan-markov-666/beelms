# Списък със Задачи (Project Backlog)

Този документ проследява разбиването на потребителските истории от `prd.md` на конкретни технически задачи.

---

## Epic 1: Foundation & Public Access

### Story 1.1: Project Setup & Infrastructure

*As a developer, I want to establish the basic project structure and development environment, so that the team can efficiently develop and deploy the application.*

#### Задачи (Tasks):

- **Task 1.1.1: Инициализиране на Monorepo структура**
  - [ ] Инициализиране на `git` репозитори.
  - [ ] Конфигуриране на `pnpm workspaces` в главния `package.json`.
  - [ ] Създаване на основната директорийна структура: `apps/web`, `apps/admin`, `apps/backend`, `packages/shared-types`, `packages/ui-components`, `packages/constants`.
  - [ ] Добавяне на `.gitignore` файл с основни правила за Node.js, OS файлове и `.env`.
  - **Документация:**
    - **README.md**: Добавяне на секция "Структура на проекта", която описва предназначението на всяка директория в `apps` и `packages`.

- **Task 1.1.2: Конфигуриране на TypeScript**
  - [ ] Създаване на базов `tsconfig.base.json` в главната директория.
  - [ ] Създаване на индивидуални `tsconfig.json` файлове във всеки проект (`apps/*`) и пакет (`packages/*`), които наследяват базовия.
  - [ ] Активиране на `"strict": true` и други препоръчителни `compilerOptions`.
  - **Документация:**
    - **README.md**: Добавяне на секция "TypeScript конфигурация", обясняваща ролята на `tsconfig.base.json` и как проектните `tsconfig.json` го наследяват.

- **Task 1.1.3: Настройка на Docker среда за локална разработка**
  - [ ] Създаване на `docker-compose.yml` файл.
  - [ ] Дефиниране на `service` за PostgreSQL базата данни.
  - [ ] Създаване на `Dockerfile` за `backend` приложението.
  - [ ] Добавяне на `.env.example` файл в `apps/backend` с променливи за Docker средата.
  - **Документация:**
    - **README.md**: Добавяне на секция "Локална разработка", която обяснява как да се стартира проекта с `docker-compose up`. Да се спомене и `.env.example`.

- **Task 1.1.4: Имплементиране на управление на конфигурацията**
  - [ ] Инсталиране на `@nestjs/config` в `backend` приложението.
  - [ ] Създаване на модул за валидация на променливите на средата (напр. `DATABASE_URL`, `PORT`) при стартиране на приложението.
  - [ ] **Unit Test**: Добавяне на тест, който проверява, че приложението хвърля грешка при липсваща или невалидна задължителна променлива.
  - **Документация:**
    - **README.md**: Описание на стратегията за управление на конфигурацията и задължителните променливи на средата.
    - **TESTS.md**: Документиране на Unit теста, който валидира поведението при липсващи променливи.

- **Task 1.1.5: Настройка на базов CI/CD Pipeline**
  - [ ] Създаване на директория `.github/workflows`.
  - [ ] Създаване на `ci.yml` workflow, който се задейства при `push` и `pull_request`.
  - [ ] Workflow-ът трябва да инсталира зависимости с `pnpm install` и да изпълнява `lint` и `build` команди, за да валидира целостта на проекта.
  - [ ] **Regression Suite**: Дефиниране на npm скрипт (`test:regression`), който изпълнява всички видове тестове (unit, integration, e2e) в целия проект.
  - [ ] **CI Integration**: Интегриране на `test:regression` скрипта в `ci.yml`, така че да се изпълнява автоматично след `build` стъпката. Това ще гарантира, че с всеки commit регресионният пакет расте и валидира цялата система.
  - **Документация:**
    - **README.md**: Добавяне на секция "CI/CD", която обяснява целта на `ci.yml` и скрипта `test:regression`.
    - **TESTS.md**: Създаване на секция "Regression Suite", която описва целта на `test:regression`.

---

### Story 1.2: Core Data Models & Database Schema

*As a developer, I want to establish the core database schema and data models, so that the application has a solid data foundation.*

#### Задачи (Tasks):

- **Task 1.2.1: Дефиниране на TypeORM Entities**
  - [ ] Инсталиране на `typeorm`, `@nestjs/typeorm`, и `pg` в `backend` проекта.
  - [ ] Създаване на `User` entity (`user.entity.ts`) съгласно `architecture.md`.
  - [ ] Създаване на `Category`, `Course`, `Topic`, `Test`, `Question` entities.
  - [ ] Създаване на `UserProgress`, `UserCourseProgress`, и `SystemSetting` entities.
  - [ ] Дефиниране на всички релации (One-to-Many, Many-to-One) между entities.
  - [ ] Всички entities трябва да включват базови полета като `id` (uuid), `createdAt`, `updatedAt`.
  - [ ] **Integration Test**: Добавяне на тест за ключови entities (`User`, `Course`), който проверява правилното записване и извличане от тестова база данни, както и коректността на релациите.
  - **Документация:**
    - **README.md**: Добавяне на диаграма или описание на релациите между основните entities.
    - **TESTS.md**: Документиране на integration теста за entities, като се обясни, че той проверява CRUD операциите и релациите.

- **Task 1.2.2: Конфигуриране на TypeORM и Миграции**
  - [ ] Конфигуриране на TypeORM връзката с базата данни в `backend` (`AppModule`), използвайки `@nestjs/config`.
  - [ ] Настройване на TypeORM CLI за генериране и изпълнение на миграции.
  - [ ] Генериране на първоначална миграция, която създава всички таблици (`npm run typeorm -- migration:generate ...`).
  - [ ] Добавяне на npm скрипт (`migration:run`) за лесно прилагане на миграциите.
  - [ ] **Smoke Test**: Добавяне на стъпка в CI pipeline, която стартира празна база данни и изпълнява `migration:run`, за да се валидира, че миграциите са синтактично коректни.
  - **Документация:**
    - **README.md**: Добавяне на секция "Миграции на базата данни" с инструкции как се генерират и прилагат миграции.
    - **TESTS.md**: Документиране на smoke теста, който валидира синтактичната коректност на миграциите в CI.

- **Task 1.2.3: Настройка на Data Seeding**
  - [ ] Инсталиране на `@faker-js/faker`.
  - [ ] Създаване на структура за seeder файлове (`src/database/seeders`).
  - [ ] Имплементиране на seeder за `Category` и `User` (с `admin` роля).
  - [ ] Създаване на CLI команда в NestJS (`npm run cli -- db:seed`) за изпълнение на seeder-ите.
  - [ ] **Integration Test**: Добавяне на тест, който изпълнява seeder-а срещу празна база данни и проверява дали данните са създадени коректно.
  - [ ] **Ръчна проверка**: Валидиране на данните в базата след изпълнение на seeder-а.
  - **Документация:**
    - **README.md**: Добавяне на секция "Попълване на данни (Seeding)" с инструкция как се изпълнява seeder командата.
    - **TESTS.md**: Документиране на integration теста, който валидира, че seeder-ът работи коректно.

---

### Story 1.3: Basic API Foundation

*As a developer, I want to establish the basic NestJS API structure, so that frontend applications can communicate with the backend.*

#### Задачи (Tasks):

- **Task 1.3.1: Настройка на глобални модули и конфигурация**
  - [ ] Инсталиране на `class-validator` и `class-transformer`.
  - [ ] Конфигуриране на глобален `ValidationPipe` в `main.ts` за автоматична валидация на всички входящи DTO-та.
  - [ ] Активиране на CORS (`enableCors()`) в `main.ts`, за да се позволи комуникация с frontend приложенията.
  - [ ] **Integration Test**: Добавяне на тест, който изпраща заявка с невалидни данни (DTO) и проверява дали се връща `400 Bad Request`, за да се валидира, че `ValidationPipe` работи глобално.
  - **Документация:**
    - **README.md**: Описание на глобалния `ValidationPipe` и конфигурацията на CORS.
    - **TESTS.md**: Документиране на Integration теста за глобалния `ValidationPipe`.

- **Task 1.3.2: Имплементиране на Health Check Endpoint**
  - [ ] Инсталиране на `@nestjs/terminus`.
  - [ ] Създаване на `HealthModule` и `HealthController`.
  - [ ] Имплементиране на `GET /health` ендпойнт, който проверява състоянието на базата данни.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тест, който извиква `GET /health` и проверява за успешен `200 OK` отговор.
  - [ ] **Ръчна проверка**: Извикване на ендпойнта през браузър или API клиент.
  - **Документация:**
    - **README.md**: Споменаване на `GET /health` ендпойнта в секция за API.
    - **TESTS.md**: Документиране на Integration теста за health check ендпойнта.

- **Task 1.3.3: Централизирана обработка на грешки и логване**
  - [ ] Инсталиране и конфигуриране на `nestjs-pino` за структурирано логване (JSON формат).
  - [ ] Конфигуриране на `pino` в `main.ts`.
  - [ ] Създаване на глобален `ExceptionFilter`, който улавя всички грешки и връща стандартизиран JSON отговор.
  - [ ] Интегриране на Sentry SDK за докладване на грешки, както е описано в `architecture.md`.
  - [ ] **Integration Test**: Добавяне на тест, който проверява дали глобалният филтър за грешки работи правилно и докладва грешки до Sentry.
  - [ ] **Ръчна проверка**: Ръчно предизвикване на грешка, за да се провери консистентността на отговора.
  - **Документация:**
    - **README.md**: Описание на структурата на логовете и стандартизирания формат за грешки.
    - **TESTS.md**: Документиране на integration теста за Exception Filter-а.

- **Task 1.3.4: Настройка на Rate Limiting**
  - [ ] Инсталиране и конфигуриране на `nestjs-throttler`.
  - [ ] Прилагане на глобално правило за ограничаване на заявките като защита по подразбиране.
  - [ ] Подготвяне на конфигурацията за лесно добавяне на по-строги правила за специфични ендпойнтове по-късно.
  - [ ] **Integration Test**: Добавяне на тест, който изпраща множество заявки към даден ендпойнт в кратък период и проверява дали след N-тата заявка се връща `429 Too Many Requests`.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на глобалната политика за rate limiting.
    - **TESTS.md**: Документиране на Integration теста, който проверява връщането на `429 Too Many Requests`.

---

### Story 1.4: Public Content API Endpoints

*As a guest user, I want to access course and lesson content through API endpoints, so that I can browse educational content without registration.*

#### Задачи (Tasks):

- **Task 1.4.1: Създаване на модули за съдържание**
  - [ ] Създаване на `CategoriesModule`, `CoursesModule`, и `TopicsModule` в `apps/backend`.
  - [ ] Всеки модул трябва да съдържа `Controller` и `Service` файлове.
  - [ ] Импортиране на новите модули в главния `AppModule`.
  - [ ] **Unit Test**: Добавяне на тестове за модулите, за да се провери дали работят правилно.
  - **Документация:**
    - **README.md**: Описание на предназначението на новите модули за съдържание.
    - **TESTS.md**: Документиране на unit тестовете за модулите.

- **Task 1.4.2: Имплементиране на публични ендпойнти**
  - [ ] `GET /categories`: Имплементиране на логика в `CategoriesService` и `CategoriesController` за връщане на списък с всички категории.
  - [ ] `GET /courses`: Имплементиране на логика в `CoursesService` за връщане на курсове с пагинация и филтриране по ID на категория.
  - [ ] `GET /courses/:id`: Имплементиране на логика за връщане на един курс с всичките му лекции.
  - [ ] `GET /topics/:id`: Имплементиране на логика за връщане на съдържанието на една лекция.
  - [ ] **Integration Test**: Добавяне на тестове за всички ендпойнти, за да се провери дали работят правилно и връщат очакваните данни.
  - [ ] **Ръчна проверка**: Валидиране на ендпойнтите през API клиент (Postman, Insomnia).
  - **Документация:**
    - **README.md**: Документиране на новите публични ендпойнти в секцията за API.
    - **TESTS.md**: Документиране на integration тестовете за всеки от публичните ендпойнти.

- **Task 1.4.3: Дефиниране на DTO-та и API документация**
  - [ ] Създаване на Response DTO-та (Data Transfer Objects) в `packages/shared-types` за всеки публичен ендпойнт, за да се осигури консистентен формат на отговорите.
  - [ ] Инсталиране и конфигуриране на `@nestjs/swagger` в `main.ts`.
  - [ ] Добавяне на `@Api...` декоратори към контролерите и DTO-тата за генериране на OpenAPI (Swagger) документация.
  - [ ] **Unit Test**: Добавяне на тестове за DTO-тата, за да се валидират правилата с `class-validator`.
  - [ ] **Snapshot Test**: Добавяне на тест, който генерира `swagger.json` файла и го сравнява със запазена "снимка" (snapshot), за да се предотвратят случайни промени в API контракта.
  - [ ] **Ръчна проверка**: Отваряне на Swagger UI в браузър и проверка на генерираната документация.
  - **Документация:**
    - **README.md**: Добавяне на секция "API Документация" с линк и инструкции как се достъпва Swagger UI.
    - **TESTS.md**: Документиране на unit тестовете за DTO-тата и snapshot теста за Swagger документацията.

---

## Epic 2: User Authentication & Management

### Story 2.1: User Registration

*As a new user, I want to be able to register for an account, so that I can access personalized features.*

#### Задачи (Tasks):

- **Task 2.1.1: Създаване на Authentication Module (Backend)**
  - [ ] Създаване на `AuthModule` в `apps/backend`.
  - [ ] Инсталиране на необходимите пакети: `@nestjs/jwt`, `@nestjs/passport`, `passport`, `passport-jwt`, `bcrypt`.
  - [ ] Създаване на `AuthService` и `AuthController`.
  - [ ] Имплементиране на логика за хеширане на пароли с `bcrypt` в `UserService` или `AuthService`.
  - [ ] **Unit Test**: Добавяне на тестове за Authentication Module, за да се провери дали работи правилно.
  - **Документация:**
    - **README.md**: Описание на `AuthModule` и неговите отговорности.
    - **TESTS.md**: Документиране на unit тестовете за `AuthModule`.

- **Task 2.1.2: Имплементиране на Registration Endpoint (Backend)**
  - [ ] Създаване на `POST /auth/register` ендпойнт.
  - [ ] Създаване на `RegisterUserDto` с валидация за `email`, `password`, `firstName`, `lastName`.
  - [ ] Имплементиране на логика в `AuthService` за проверка дали потребител с такъв имейл вече съществува.
  - [ ] Създаване на нов потребител в базата данни при успешна валидация.
  - [ ] Връщане на новосъздадения потребителски обект (без паролата).
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тестове за Registration Endpoint, за да се провери дали работи правилно.
  - [ ] **Ръчна проверка**: Тестване на ендпойнта с API клиент (успешна и неуспешна регистрация).
  - **Документация:**
    - **README.md**: Документиране на `POST /auth/register` ендпойнта.
    - **TESTS.md**: Документиране на integration теста за регистрация, включително случаи на успех и грешка (дублиран имейл).

- **Task 2.1.3: Създаване на Registration Page (Frontend)**
  - [ ] Създаване на нова страница/рут `/register` в `apps/web`.
  - [ ] Създаване на компонент за регистрационна форма с полета за имейл, парола, име и фамилия.
  - [ ] Имплементиране на клиентска валидация на формата.
  - [ ] **Component Test**: Добавяне на тестове за регистрационната форма, за да се провери дали работи правилно.
  - [ ] **Ръчна проверка**: Тестване на валидациите и поведението на формата в браузър.
  - **Документация:**
    - **README.md**: Описание на компонента за регистрационна форма и неговите валидации.
    - **TESTS.md**: Документиране на component теста за формата за регистрация (проверка на валидации и състояние).

- **Task 2.1.4: Интеграция на формата за регистрация с API (Frontend)**
  - [ ] При изпращане на формата, извикване на `POST /auth/register` ендпойнта.
  - [ ] Обработка на успешна регистрация (напр. показване на съобщение за успех и пренасочване към страницата за вход).
  - [ ] Обработка на грешки от API-то (напр. показване на съобщение "Потребител с този имейл вече съществува").
  - [ ] **E2E Test**: Добавяне на тест, който симулира целия процес: потребителят попълва формата за регистрация, изпраща я и проверява за съобщение за успех.
  - [ ] **Ръчна проверка**: Изпълнение на целия процес по регистрация в браузър.
  - **Документация:**
    - **README.md**: Описание на логиката за интеграция с API-то, включително обработка на успехи и грешки.
    - **TESTS.md**: Документиране на E2E теста за процеса на регистрация от край до край.

---

### Story 2.2: User Login

*As a registered user, I want to be able to log in to my account, so that I can access my personalized content and features.*

#### Задачи (Tasks):

- **Task 2.2.1: Имплементиране на JWT Стратегия (Backend)**
  - [ ] Конфигуриране на `JwtModule` в `AuthModule` със секретен ключ и време на валидност (`expiresIn`), заредени от `.env` файла.
  - [ ] Създаване на `JwtStrategy` (`jwt.strategy.ts`), която валидира payload-а на токена.
  - [ ] Имплементиране на `LocalStrategy` (`local.strategy.ts`) за валидиране на потребителско име и парола.
  - [ ] **Unit Test**: Добавяне на тестове за JWT стратегията, за да се провери дали работи правилно.
  - **Документация:**
    - **README.md**: Описание на `JwtStrategy` и `LocalStrategy`.
    - **TESTS.md**: Документиране на unit тестовете за стратегиите за автентикация.

- **Task 2.2.2: Имплементиране на Login Endpoint (Backend)**
  - [ ] Създаване на `POST /auth/login` ендпойнт, защитен с `LocalAuthGuard`.
  - [ ] Създаване на `LoginUserDto` с `email` и `password`.
  - [ ] При успешна автентикация, `AuthService` трябва да генерира и върне `access_token` и `refresh_token`.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тестове за Login Endpoint, за да се провери дали работи правилно.
  - [ ] **Ръчна проверка**: Тестване на ендпойнта с API клиент (успешен и неуспешен логин).
  - **Документация:**
    - **README.md**: Документиране на `POST /auth/login` ендпойнта и обяснение на връщаните токени.
    - **TESTS.md**: Документиране на integration теста за логин процеса.

- **Task 2.2.3: Създаване на Login Page (Frontend)**
  - [ ] Създаване на нова страница/рут `/login` в `apps/web`.
  - [ ] Създаване на компонент за форма за вход с полета за имейл и парола.
  - [ ] Имплементиране на клиентска валидация на формата.
  - [ ] **Component Test**: Добавяне на тестове за формата за вход, за да се провери дали работи правилно.
  - [ ] **Ръчна проверка**: Тестване на валидациите и поведението на формата в браузър.
  - **Документация:**
    - **README.md**: Описание на компонента за форма за вход.
    - **TESTS.md**: Документиране на component теста за формата за вход.

- **Task 2.2.4: Интеграция на формата за вход с API (Frontend)**
  - [ ] При изпращане на формата, извикване на `POST /auth/login`.
  - [ ] При успешен отговор, съхраняване на `access_token` и `refresh_token` (напр. в `localStorage` или `cookie`).
  - [ ] Конфигуриране на `axios` клиента да изпраща `Authorization: Bearer <token>` хедър с всяка следваща заявка.
  - [ ] Пренасочване на потребителя към неговото табло (`/dashboard`) след успешен вход.
  - [ ] Обработка на грешки (напр. "Грешен имейл или парола").
  - [ ] **E2E Test**: Добавяне на тест, който симулира целия процес: потребителят попълва формата за вход, изпраща я и проверява дали е пренасочен към таблото (`/dashboard`).
  - [ ] **Ръчна проверка**: Изпълнение на целия процес по вход в браузър.
  - **Документация:**
    - **README.md**: Описание на логиката за съхранение на токени и пренасочване след успешен вход.
    - **TESTS.md**: Документиране на E2E теста за процеса на вход от край до край.

---

### Story 2.3: Secure Session & Access Control

*As a logged-in user, I want my session to be secure and to be able to log out, so that my account is protected.*

#### Задачи (Tasks):

- **Task 2.3.1: Имплементиране на защитени маршрути (Backend)**
  - [ ] Прилагане на `JwtAuthGuard` към ендпойнти, които изискват автентикация (напр. `GET /profile`).
  - [ ] Създаване на къстъм декоратор `@GetUser()`, който да се използва за лесно извличане на потребителския обект от `request`-а.
  - [ ] Създаване на `GET /auth/profile` ендпойнт, който връща информация за текущо логнатия потребител.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тест, който се опитва да достъпи защитен ендпойнт (напр. `/auth/profile`) без токен и с невалиден токен, като проверява за `401 Unauthorized` отговор.
  - [ ] **Ръчна проверка**: Тестване на достъпа до `GET /auth/profile` с и без токен.
  - **Документация:**
    - **README.md**: Документиране на `GET /auth/profile` и обяснение как се защитават ендпойнти.
    - **TESTS.md**: Документиране на integration теста за `JwtAuthGuard`, който валидира защитата на ендпойнтите.

- **Task 2.3.2: Имплементиране на Refresh Token механизъм (Backend)**
  - [ ] Създаване на `POST /auth/refresh` ендпойнт.
  - [ ] Логиката трябва да приема `refresh_token`, да го валидира и ако е валиден, да издава нов `access_token`.
  - [ ] При логин, `refresh_token` трябва да се съхранява в базата данни (хеширан) и да се свързва с потребителя, за да може да бъде оттеглен (revoked).
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тестове за Refresh Token механизма, за да се провери дали работи правилно.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Документиране на `POST /auth/refresh` ендпойнта.
    - **TESTS.md**: Документиране на integration теста за опресняване на токени.

- **Task 2.3.3: Имплементиране на защитени маршрути (Frontend)**
  - [ ] Създаване на компонент `ProtectedRoute`, който проверява за наличието на `access_token`.
  - [ ] Ако няма токен, потребителят се пренасочва към `/login`.
  - [ ] Обновяване на рутирането, за да се използва `ProtectedRoute` за страници като `/dashboard`.
  - [ ] **Component Test**: Добавяне на тестове за защитените маршрути, за да се провери дали работят правилно.
  - [ ] **Ръчна проверка**: Опит за достъп до защитена страница без логнат потребител.
  - **Документация:**
    - **README.md**: Описание на компонента `ProtectedRoute` и неговата роля.
    - **TESTS.md**: Документиране на component тестовете за `ProtectedRoute`.

- **Task 2.3.4: Имплементиране на Logout и Token Refresh (Frontend)**
  - [ ] Създаване на `useAuth` hook, който предоставя информация за потребителя и статус на автентикация.
  - [ ] Имплементиране на бутон/линк за изход, който изчиства токените от хранилището и пренасочва към началната страница.
  - [ ] Имплементиране на логика в `axios` interceptor, която при грешка `401 Unauthorized` автоматично да се опитва да обнови токена чрез `/auth/refresh` ендпойнта.
  - [ ] **Integration Test**: Добавяне на тестове за Logout и Token Refresh, за да се провери дали работят правилно.
  - [ ] **Ръчна проверка**: Тестване на бутона за изход и автоматичното опресняване на токена.
  - **Документация:**
    - **README.md**: Описание на `useAuth` hook-а и логиката за опресняване на токени.
    - **TESTS.md**: Документиране на integration тестовете за изход и опресняване на токен.

---

### Story 2.4: Role-Based Access Control (RBAC)

*As an administrator, I want to have special permissions, so that I can manage the platform content and users.*

#### Задачи (Tasks):

- **Task 2.4.1: Имплементиране на Roles Guard (Backend)**
  - [ ] Дефиниране на `Role` enum в `packages/shared-types` (напр. `ADMIN`, `USER`).
  - [ ] Създаване на `@Roles()` декоратор, който да се използва за задаване на изискваните роли за даден ендпойнт.
  - [ ] Създаване на `RolesGuard`, който проверява дали ролята на потребителя отговаря на изискваните роли, дефинирани с `@Roles()` декоратора.
  - [ ] Прилагане на `RolesGuard` глобално или на специфични модули.
  - [ ] **Unit Test**: Добавяне на тестове за логиката в `RolesGuard`.
  - [ ] **Integration Test**: Добавяне на тест, който проверява дали ендпойнт, защитен с `@Roles('ADMIN')`, е недостъпен за потребител с роля `USER` и достъпен за `ADMIN`.
  - **Документация:**
    - **README.md**: Обяснение на системата за роли (RBAC) и как се използва `@Roles()` декораторът.
    - **TESTS.md**: Документиране на unit и integration тестовете за `RolesGuard`, покриващи както вътрешната логика, така и реалното приложение върху ендпойнти.

- **Task 2.4.2: Защита на административни ендпойнти (Backend)**
  - [ ] Създаване на примерен ендпойнт `GET /admin/stats`, който е защитен с `@Roles('ADMIN')`.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тестове за административните ендпойнти, за да се провери дали работят правилно.
  - [ ] **Ръчна проверка**: Тестване на достъпа до ендпойнта с админ и обикновен потребител.
  - **Документация:**
    - **README.md**: Документиране на примерния административен ендпойнт.
    - **TESTS.md**: Документиране на integration теста, който проверява достъпа до защитени с роля ендпойнти.

- **Task 2.4.3: Управление на достъпа в UI (Frontend)**
  - [ ] `useAuth` hook-а трябва да предоставя и ролята на текущия потребител.
  - [ ] Създаване на компонент `AdminRoute`, който защитава страници в админ панела и пренасочва потребители без `ADMIN` роля.
  - [ ] Имплементиране на условно рендиране на UI елементи (напр. бутон "Админ Панел" в хедъра се показва само на администратори).
  - [ ] **Component Test**: Добавяне на тестове за управлението на достъпа в UI, за да се провери дали работи правилно.
  - [ ] **Ръчна проверка**: Проверка дали админ бутони/менюта са видими само за админи.
  - **Документация:**
    - **README.md**: Описание на компонента `AdminRoute` и условното рендиране на база роля.
    - **TESTS.md**: Документиране на component тестовете за UI елементи, свързани с роли.

---

## Epic 3: User Dashboard & Progress Tracking

### Story 3.1: User Dashboard

*As a logged-in user, I want to see a personalized dashboard, so that I can easily view my enrolled courses and track my progress.*

#### Задачи (Tasks):

- **Task 3.1.1: Създаване на Dashboard Endpoint (Backend)**
  - [ ] Създаване на `DashboardModule` и `DashboardController`.
  - [ ] Имплементиране на `GET /dashboard` ендпойнт, защитен с `JwtAuthGuard`.
  - [ ] `DashboardService` трябва да извлича всички курсове, в които потребителят се е записал, заедно с неговия напредък за всеки курс.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тест, който проверява дали ендпойнтът връща коректни данни за логнат потребител.
  - [ ] **Ръчна проверка**: Валидиране на ендпойнта с API клиент.
  - **Документация:**
    - **README.md**: Документиране на `GET /dashboard` ендпойнта, включително очаквания формат на отговора.
    - **TESTS.md**: Документиране на integration теста за таблото, обяснявайки сценария, който покрива.

- **Task 3.1.2: Създаване на Dashboard Page (Frontend)**
  - [ ] Създаване на нова страница/рут `/dashboard`, защитена с `ProtectedRoute`.
  - [ ] При зареждане на страницата, извикване на `GET /dashboard` ендпойнта.
  - [ ] Създаване на UI, който показва списък с курсовете на потребителя.
  - [ ] За всеки курс трябва да се показва името му, изображение и индикатор за напредък.
  - [ ] **E2E Test**: Добавяне на тест, който проверява дали таблото се зарежда и показва основните секции.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на `DashboardPage` и компонентите, които използва.
    - **TESTS.md**: Документиране на E2E теста за страницата на таблото.

- **Task 3.1.3: Интеграция на Dashboard с API (Frontend)**
  - [ ] Свързване на `DashboardPage` с API клиента за извличане и показване на реални данни.
  - [ ] **Integration Test**: Добавяне на тест, който проверява дали данните за потребителя и курсовете се извличат и показват правилно.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на интеграцията на таблото с API.
    - **TESTS.md**: Документиране на integration теста за интеграцията на таблото.

---

### Story 3.2: Lesson Progress Tracking

*As a logged-in user, I want to be able to mark lessons as complete, so that I can track my learning progress accurately.*

#### Задачи (Tasks):

- **Task 3.2.1: Имплементиране на Progress Endpoint (Backend)**
  - [ ] Създаване на `POST /progress/topics/:id/complete` ендпойнт, защитен с `JwtAuthGuard`.
  - [ ] Имплементиране на логика в `ProgressService`, която записва в таблицата `UserProgress`, че дадена лекция е завършена от потребителя.
  - [ ] Логиката трябва да преизчислява и обновява общия напредък в `UserCourseProgress` след всяка завършена лекция.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тест, който проверява дали напредъкът се записва и преизчислява коректно.
  - [ ] **Ръчна проверка**: Валидиране на ендпойнта с API клиент.
  - **Документация:**
    - **README.md**: Документиране на `POST /progress/topics/:id/complete` ендпойнта.
    - **TESTS.md**: Документиране на integration теста за маркиране на лекция като завършена.

- **Task 3.2.2: Визуализация на прогреса (Frontend)**
  - [ ] Създаване на компонент `<ProgressBar>` в `packages/ui-components`.
  - [ ] Интегриране на `<ProgressBar>` в картата на всеки курс на таблото.
  - [ ] **Component Test**: Добавяне на тестове за компонентите, които визуализират прогреса.
  - [ ] **Ръчна проверка**: Визуална инспекция на UI елементите за прогрес.
  - **Документация:**
    - **README.md**: Описание на компонента `<ProgressBar>`.
    - **TESTS.md**: Документиране на component теста за `<ProgressBar>`.

- **Task 3.2.3: Интеграция на бутон за завършване (Frontend)**
  - [ ] На страницата на лекцията (`TopicPage`) добавяне на бутон "Маркирай като завършена".
  - [ ] При натискане на бутона, извикване на `POST /progress/topics/:id/complete`.
  - [ ] **Integration Test**: Добавяне на тест, който симулира завършване на лекция и проверява дали UI-ът се обновява.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на логиката за завършване на лекция.
    - **TESTS.md**: Документиране на integration теста за процеса по завършване на лекция.

---

## Epic 4: Testing System & Assessment

### Story 4.1: View Test & Questions

*As a user, I want to be able to view the questions of a test, so that I can prepare to answer them.*

#### Задачи (Tasks):

- **Task 4.1.1: Създаване на Test Endpoints (Backend)**
  - [ ] Създаване на `TestsModule` и `QuestionsModule` в `apps/backend`.
  - [ ] Имплементиране на `GET /tests/:id` ендпойнт, който връща информация за теста и списък с въпросите към него.
  - [ ] **Важно**: Отговорът НЕ трябва да съдържа информация за верния отговор на въпросите.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тест, който проверява дали ендпойнтът връща въпроси без верните им отговори.
  - [ ] **Ръчна проверка**: Валидиране на ендпойнта с API клиент.
  - **Документация:**
    - **README.md**: Документиране на `GET /tests/:id` ендпойнта.
    - **TESTS.md**: Документиране на integration теста за извличане на въпроси за тест.

- **Task 4.1.2: Създаване на Test Page (Frontend)**
  - [ ] Създаване на нова страница/рут `/tests/:id`, защитена с `ProtectedRoute`.
  - [ ] Показване на името и описанието на теста, както и списък с въпроси.
  - [ ] **Component Test**: Добавяне на тестове за компонентите за въпроси и отговори.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на `TestPage` и нейната структура.
    - **TESTS.md**: Документиране на component теста за страницата за тест.

---

### Story 4.2: Submit Test & View Results

*As a user, I want to submit my answers and see my results, so that I can assess my knowledge.*

#### Задачи (Tasks):

- **Task 4.2.1: Имплементиране на Test Submission Endpoint (Backend)**
  - [ ] Създаване на `POST /tests/:id/submit` ендпойнт, защитен с `JwtAuthGuard`.
  - [ ] Имплементиране на логика за оценяване на теста и записване на резултата.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тест, който изпраща отговори и проверява дали резултатът се изчислява и записва правилно.
  - [ ] **Ръчна проверка**: Валидиране на ендпойнта с API клиент.
  - **Документация:**
    - **README.md**: Документиране на `POST /tests/:id/submit` ендпойнта.
    - **TESTS.md**: Документиране на integration теста за подаване на тест.

- **Task 4.2.2: Имплементиране на Test Submission (Frontend)**
  - [ ] На страницата на теста (`/tests/:id`) добавяне на бутон "Предай теста".
  - [ ] При натискане на бутона, изпращане на отговорите към `POST /tests/:id/submit`.
  - [ ] **E2E Test**: Добавяне на тест, който симулира попълване и предаване на цял тест.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на логиката за предаване на тест.
    - **TESTS.md**: Документиране на E2E теста за процеса по предаване на тест.

- **Task 4.2.3: Имплементиране на страница за резултати (Backend & Frontend)**
  - [ ] Създаване на `GET /tests/results/:attemptId` ендпойнт, който връща резултатите от конкретен опит.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тест, който проверява дали ендпойнтът връща правилните резултати за даден потребител и тест.
  - [ ] **Ръчна проверка**: Валидиране на ендпойнта с API клиент.
  - [ ] Създаване на страница `/tests/results/:attemptId`, която показва резултатите.
  - [ ] **Component Test**: Добавяне на тестове за компонента, който показва резултатите от теста.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - [ ] Интеграция на страницата с API ендпойнта.
  - [ ] **Integration Test**: Добавяне на тест, който проверява дали UI-ът коректно показва данните, получени от API-то.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на страницата за резултати и `GET` ендпойнта.
    - **TESTS.md**: Документиране на тестовете за показване на резултати.

---

## Epic 5: Admin Panel & Content Management

### Story 5.1: Course & Category Management

*As an admin, I want to be able to create, update, and delete courses and categories, so that I can manage the educational content.*

#### Задачи (Tasks):

- **Task 5.1.1: Инициализиране на Admin Frontend (apps/admin)**
  - [ ] Инициализиране на ново React приложение с Vite в `apps/admin`.
  - [ ] Конфигуриране на TypeScript, ESLint, Prettier и `react-router-dom`.
  - [ ] **Unit Test**: Добавяне на тест за базовата конфигурация на приложението.
  - [ ] **Ръчна проверка**: Визуална инспекция на базовия layout.
  - **Документация:**
    - **README.md**: Добавяне на секция за `apps/admin` с инструкции за стартиране.
    - **TESTS.md**: Документиране на unit теста за конфигурацията.

- **Task 5.1.2: Имплементиране на Admin CRUD Endpoints (Backend)**
  - [ ] Имплементиране на CRUD ендпойнти за `Categories` (`/admin/categories`) и `Courses` (`/admin/courses`).
  - [ ] Всички ендпойнти трябва да са защитени с `RolesGuard('ADMIN')`.
  - [ ] Добавяне на @Api... декоратори за Swagger документация.
  - [ ] **Integration Test**: Добавяне на тестове, които проверяват CRUD операциите и защитата с `RolesGuard`.
  - [ ] **Ръчна проверка**: Тестване на ендпойнтите с API клиент, използвайки админски токен.
  - **Документация:**
    - **README.md**: Документиране на административните CRUD ендпойнти за курсове и категории.
    - **TESTS.md**: Документиране на integration тестовете за административните ендпойнти.

- **Task 5.1.3: Създаване на UI за управление на категории (Frontend)**
  - [ ] Създаване на страница `/admin/categories` с CRUD функционалност.
  - [ ] **Component Test**: Тестване на CRUD компонентите за управление на категории.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на UI компонентите за управление на категории.
    - **TESTS.md**: Документиране на component тестовете за UI за управление на категории.

- **Task 5.1.4: Създаване на UI за управление на курсове (Frontend)**
  - [ ] Създаване на страница `/admin/courses` с CRUD функционалност.
  - [ ] **Component Test**: Тестване на CRUD компонентите за управление на курсове.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на UI компонентите за управление на курсове.
    - **TESTS.md**: Документиране на component тестовете за UI за управление на курсове.

---

### Story 5.2: Lesson & Content Management

*As an admin, I want to be able to add, edit, and delete lessons (topics) within a course, so that I can structure the learning material.*

#### Задачи (Tasks):

- **Task 5.2.1: Имплементиране на Admin Topic Endpoints (Backend)**
  - [ ] Имплементиране на CRUD ендпойнти за `Topics` (`/admin/courses/:courseId/topics`), защитени с `RolesGuard('ADMIN')`.
  - [ ] **Integration Test**: Добавяне на тестове за CRUD операциите с лекции.
  - [ ] **Ръчна проверка**: Тестване на ендпойнтите с API клиент, използвайки админски токен.
  - **Документация:**
    - **README.md**: Документиране на административните CRUD ендпойнти за лекции.
    - **TESTS.md**: Документиране на integration тестовете за управление на лекции.

- **Task 5.2.2: Създаване на UI за управление на лекции (Frontend)**
  - [ ] Създаване на страница `/admin/courses/:id`, която показва детайли за курса и таблица с неговите лекции.
  - [ ] **Component Test**: Тестване на UI компонентите за управление на лекции.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на UI за управление на лекции.
    - **TESTS.md**: Документиране на component тестовете за UI за управление на лекции.

- **Task 5.2.3: Интегриране на Rich Text Editor (Frontend)**
  - [ ] Интегриране на rich text editor (напр. Tiptap) във формата за създаване/редактиране на лекция.
  - [ ] **Component Test**: Добавяне на тест, който проверява дали редакторът се зарежда и работи коректно.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на избрания Rich Text Editor и неговата интеграция.
    - **TESTS.md**: Документиране на component теста за Rich Text Editor-а.

---

### Story 5.3: Test & Question Management

*As an admin, I want to create and manage tests and their questions, so that I can assess user knowledge effectively.*

#### Задачи (Tasks):

- **Task 5.3.1: Имплементиране на Admin Test/Question Endpoints (Backend)**
  - [ ] Имплементиране на CRUD ендпойнти за `Tests` (`/admin/tests`) и `Questions` (`/admin/tests/:testId/questions`).
  - [ ] Всички ендпойнти трябва да са защитени с `RolesGuard('ADMIN')`.
  - [ ] **Integration Test**: Добавяне на тестове за CRUD ендпойнтите за тестове и въпроси, включително проверка на RBAC.
  - [ ] **Ръчна проверка**: Тестване на ендпойнтите с API клиент, използваййки админски токен.
  - **Документация:**
    - **README.md**: Документиране на административните CRUD ендпойнти за тестове и въпроси.
    - **TESTS.md**: Документиране на integration тестовете за управление на тестове и въпроси.

- **Task 5.3.2: Създаване на UI за управление на тестове (Frontend)**
  - [ ] Създаване на страница `/admin/tests` с CRUD функционалност за тестовете.
  - [ ] **Component Test**: Тестване на CRUD компонентите за управление на тестове.
  - [ ] **Ръчна проверка**: Валидиране на функционалността от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на UI за управление на тестове.
    - **TESTS.md**: Документиране на component тестовете за UI за управление на тестове.

- **Task 5.3.3: Създаване на UI за управление на въпроси (Frontend)**
  - [ ] Създаване на страница `/admin/tests/:id` с CRUD функционалност за въпросите към даден тест.
  - [ ] **E2E Test**: Добавяне на тест, който симулира целия процес: създаване на тест, добавяне на въпроси, редактиране и изтриване.
  - [ ] **Ръчна проверка**: Валидиране на целия работен процес от потребителска гледна точка.
  - **Документация:**
    - **README.md**: Описание на UI за управление на въпроси.
    - **TESTS.md**: Документиране на E2E теста за цялостния работен процес по управление на въпроси.
