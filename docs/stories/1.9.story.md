# 1.9: Криптиране на чувствителни данни

## Описание
Имплементиране на механизъм за криптиране на чувствителни лични данни в базата данни с AES-256.

## Технически детайли
- Използване на AES-256 за криптиране на чувствителни данни като:
  - Имейл адреси
  - Лични имена
  - Други лични идентификатори
- Безопасно съхранение на криптографски ключове
- Механизъм за ротация на ключовете
- Имплементиране на TypeORM трансформери за автоматично криптиране/декриптиране

## Реализация

### Услуга за криптиране
```typescript
@Injectable()
export class EncryptionService {
  private readonly encryptionKey: Buffer;
  private readonly algorithm = 'aes-256-gcm';

  constructor(
    private readonly configService: ConfigService,
  ) {
    // Получаване на ключ от защитено хранилище
    const key = this.configService.get<string>('ENCRYPTION_KEY');
    this.encryptionKey = Buffer.from(key, 'hex');
  }

  /**
   * Криптира данни с AES-256-GCM
   * @param text Текст за криптиране
   * @returns Криптиран текст във формат: iv:authTag:криптиран_текст
   */
  encrypt(text: string): string {
    if (!text) {
      return text;
    }
    
    // Генериране на случаен IV
    const iv = crypto.randomBytes(16);
    
    // Създаване на шифър
    const cipher = crypto.createCipheriv(this.algorithm, this.encryptionKey, iv);
    
    // Криптиране на данните
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    // Получаване на authentication tag
    const authTag = cipher.getAuthTag().toString('hex');
    
    // Връщане на форматирано: iv:authTag:криптиран_текст
    return `${iv.toString('hex')}:${authTag}:${encrypted}`;
  }

  /**
   * Декриптира данни криптирани с AES-256-GCM
   * @param encryptedText Криптиран текст във формат: iv:authTag:криптиран_текст
   * @returns Декриптиран текст
   */
  decrypt(encryptedText: string): string {
    if (!encryptedText) {
      return encryptedText;
    }
    
    // Разделяне на компонентите
    const [ivHex, authTagHex, encryptedHex] = encryptedText.split(':');
    
    if (!ivHex || !authTagHex || !encryptedHex) {
      throw new Error('Invalid encrypted format');
    }
    
    // Преобразуване на hex в Buffer
    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');
    
    // Създаване на decipher
    const decipher = crypto.createDecipheriv(this.algorithm, this.encryptionKey, iv);
    decipher.setAuthTag(authTag);
    
    // Декриптиране
    let decrypted = decipher.update(encryptedHex, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

### TypeORM трансформер за автоматично криптиране/декриптиране
```typescript
import { ValueTransformer } from 'typeorm';
import { EncryptionService } from '../services/encryption.service';

export class EncryptionTransformer implements ValueTransformer {
  constructor(private readonly encryptionService: EncryptionService) {}

  to(value: string): string {
    return value ? this.encryptionService.encrypt(value) : value;
  }

  from(value: string): string {
    return value ? this.encryptionService.decrypt(value) : value;
  }
}
```

### Интеграция с entity
```typescript
@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({
    transformer: new EncryptionTransformer(container.get(EncryptionService))
  })
  email: string;

  @Column({
    transformer: new EncryptionTransformer(container.get(EncryptionService))
  })
  firstName: string;

  @Column({
    transformer: new EncryptionTransformer(container.get(EncryptionService))
  })
  lastName: string;
  
  // Останалите полета...
}
```

## Конфигурация

### Генериране и съхраняване на ключ
```typescript
const generateEncryptionKey = (): string => {
  return crypto.randomBytes(32).toString('hex');
};
```

### Настройка на средата
```
# .env.development
ENCRYPTION_KEY=<32-байтов-ключ-в-hex-формат>

# .env.test
ENCRYPTION_KEY=<тестов-32-байтов-ключ-в-hex-формат>

# .env.production
ENCRYPTION_KEY=<production-ключ-от-защитено-хранилище>
```

## Сигурностни практики
- Ключовете **никога** не трябва да бъдат съхранявани в сорс контрол системата
- В production, ключовете трябва да се съхраняват в услуга за управление на тайни (напр. AWS Secrets Manager, HashiCorp Vault)
- Периодична ротация на ключовете (на 90 дни)
- Имплементиране на механизъм за ротация на ключове без прекъсване на услугата

## Критерии за приемане
- [ ] Всички чувствителни данни се криптират автоматично преди запис в БД
- [ ] Всички чувствителни данни се декриптират автоматично при четене от БД
- [ ] Unit тестове за функционалността с >90% покритие
- [ ] Интеграционни тестове, потвърждаващи правилното криптиране/декриптиране
- [ ] Правилна конфигурация за различни среди (dev, test, prod)
- [ ] Документиран процес за ротация на ключове

## Зависимости
- [AUTH-1-T1](AUTH-1-T1.md) - Миграции на базата данни

## Свързани файлове
- `src/shared/services/encryption.service.ts`
- `src/shared/transformers/encryption.transformer.ts`
- `src/auth/entities/user.entity.ts`
- `test/shared/services/encryption.service.spec.ts`

## Сигурност
- Не логвайте ключове или криптирани данни
- Прилагайте принципа на най-малките привилегии за достъп до ключовете
- Осигурете механизъм за одит на достъпа до криптографски ключове
