# Системна архитектура на QA4Free

_Роля: Architect. Фаза: BMAD Solutioning. Описва техническата архитектура и нефункционалните изисквания за MVP._

## Съдържание
- [Системна архитектура на QA4Free](#системна-архитектура-на-qa4free)
  - [Съдържание](#съдържание)
  - [Въведение](#въведение)
  - [Архитектурен стил](#архитектурен-стил)
  - [Високо ниво](#високо-ниво)
  - [Компоненти](#компоненти)
  - [Потребителски роли и права](#потребителски-роли-и-права)
    - [Администратор](#администратор)
    - [Потребител (регистриран)](#потребител-регистриран)
    - [Гост (нерегистриран потребител)](#гост-нерегистриран-потребител)
  - [Управление на версиите на Wiki съдържанието](#управление-на-версиите-на-wiki-съдържанието)
    - [Архитектура на версиирането](#архитектура-на-версиирането)
    - [Компоненти](#компоненти-1)
  - [GDPR съответствие](#gdpr-съответствие)
    - [Събирани данни](#събирани-данни)
    - [Права на потребителите](#права-на-потребителите)
    - [Имплементация](#имплементация)
  - [Управление на потребителски данни](#управление-на-потребителски-данни)
    - [Експорт на данни](#експорт-на-данни)
    - [Изтриване на акаунт](#изтриване-на-акаунт)
    - [Технически детайли](#технически-детайли)
  - [Технологичен стек](#технологичен-стек)
    - [Frontend](#frontend)
    - [Backend](#backend)
    - [Бази данни](#бази-данни)
    - [Инфраструктура](#инфраструктура)
    - [Мониторинг и логване](#мониторинг-и-логване)
  - [Инфраструктура](#инфраструктура-1)
    - [Хостинг](#хостинг)
    - [Домейн](#домейн)
    - [DevOps насоки за конфигурация на VPS (MVP)](#devops-насоки-за-конфигурация-на-vps-mvp)
  - [Безопасност](#безопасност)
  - [Практическа среда](#практическа-среда)
    - [Компоненти (MVP)](#компоненти-mvp)
    - [Интеграции](#интеграции)
  - [Система за метрики и анализи](#система-за-метрики-и-анализи)
    - [Събирани данни](#събирани-данни-1)
    - [Визуализация](#визуализация)
  - [Демо среда за практически задачи](#демо-среда-за-практически-задачи)
    - [Архитектура (MVP)](#архитектура-mvp)
    - [Бъдещи разширения на контейнеризацията (post-MVP)](#бъдещи-разширения-на-контейнеризацията-post-mvp)
    - [Диаграма на последователност за изпълнение на задачи](#диаграма-на-последователност-за-изпълнение-на-задачи)
  - [Масштабируемост](#масштабируемост)
  - [Заключение](#заключение)
    - [Ключови характеристики на архитектурата](#ключови-характеристики-на-архитектурата)
    - [Следващи стъпки](#следващи-стъпки)
    - [Ограничения и бъдещи разширения](#ограничения-и-бъдещи-разширения)

## Въведение
Този документ описва архитектурата на системата QA4Free - платформа за обучение по Quality Assurance, която комбинира функционалности на Wikipedia с елементи на LMS система.

## Архитектурен стил
Системата използва **микросервисна архитектура** с ясно дефинирани граници между отделните услуги. Това позволява:
- Независимо мащабиране на компонентите
- По- лесно поддържане и разширяване
- Използване на най-подходящите технологии за всеки компонент

## Високо ниво

```mermaid
C4Context
    title QA4Free - Високо ниво
    Person(user, "Потребител", "Посетител на сайта с достъп до Wiki и практическата среда")
    Person(admin, "Администратор", "Администратор на системата")
    System_Boundary(system, "QA4Free") {
        System(frontend, "Уеб приложение", "NextJS приложение", "Потребителски интерфейс")
        System_Ext(email, "Имейл услуга", "Външна имейл услуга")
    }
    
    Rel(user, frontend, "Използва", "HTTPS")
    Rel(admin, frontend, "Администрира", "HTTPS")
    Rel(frontend, email, "Изпраща имейли", "SMTP")
```

## Компоненти

```mermaid
C4Container
    title QA4Free - Компоненти (MVP)
    
    Person(user, "Потребител", "Има достъп до Wiki и Практическата среда")
    Person(admin, "Администратор", "Пълен достъп до цялата система")
    Person(guest, "Гост", "Има достъп до Wiki и Практическата среда без регистрация")
    
    Container_Boundary(frontend, "Frontend") {
        Container(web_app, "Уеб приложение", "NextJS", "Сървърно рендиране и статични файлове")
    }
    
    Container_Boundary(backend, "Backend Services") {
        Container(api_gateway, "API Gateway", "NestJS", "Маршрутизира заявките")
        Container(auth_service, "Услуга за автентикация", "NestJS", "Управление на потребители, сесии и GDPR съответствие")
        Container(wiki_service, "Wiki услуга", "NestJS", "Управление на Wiki съдържанието и версиите")
        Container(practical_env, "Практическа среда", "NestJS", "Управление на практически задачи и демо среда")
        Container(training_api, "Training API", "NestJS", "Demo REST API само за упражнения по API/integration тестване, в отделен Docker контейнер")
        Container(metrics_service, "Метрики", "NestJS", "Събиране и анализ на потребителски данни")
    }
    
    Container_Boundary(data, "Data Storage") {
        ContainerDb(postgres, "PostgreSQL", "Основно хранилище", "Съхранява всички данни")
        ContainerDb(redis, "Redis", "Кеш и сесии", "Кеширане и управление на сесии")
    }
    
    Rel(guest, web_app, "Използва", "HTTPS")
    Rel(user, web_app, "Използва", "HTTPS")
    Rel(admin, web_app, "Администрира", "HTTPS")
    Rel(web_app, api_gateway, "API заявки", "REST/HTTPS")
    Rel(api_gateway, auth_service, "Автентикация", "HTTP")
    Rel(api_gateway, wiki_service, "Wiki заявки", "HTTP")
    Rel(api_gateway, practical_env, "Практически задачи", "HTTP")
    Rel(api_gateway, training_api, "Training API заявки", "HTTP")
    Rel(api_gateway, metrics_service, "Метрики", "HTTP")
    
    Rel(auth_service, postgres, "Чете/Записва", "SQL")
    Rel(wiki_service, postgres, "Чете/Записва", "SQL")
    Rel(practical_env, postgres, "Чете/Записва", "SQL")
    Rel(metrics_service, postgres, "Чете/Записва", "SQL")
    Rel(auth_service, redis, "Управление на сесии", "Кеш")
    Rel_Back(wiki_service, redis, "Кеширане", "Кеш за често използвани данни")
```

## Потребителски роли и права

### Администратор
- Пълен достъп до цялата система
- Управление на потребители (създаване, редактиране, деактивиране)
- Създаване, редактиране и деактивиране на Wiki страници
 - Управление на версиите на Wiki страници (връщане към версия, изтриване на избрани версии)
- Преглед на метрики и анализи
- Управление на тестове и практически задачи

### Потребител (регистриран)
- Преглед на Wiki съдържание
- Използване на Практическата среда за упражнения
- Преглед на личната си активност
- Експорт на лични данни
- Изтриване на акаунт

### Гост (нерегистриран потребител)
- Преглед на Wiki съдържание
- Използване на Практическата среда за упражнения
- Възможност за регистрация

## Управление на версиите на Wiki съдържанието

### Архитектура на версиирането
- Всяка промяна в Wiki страница създава нова версия
- Пазят се пълна история на всички редакции
- Възможност за преглед на разлики между версии
- Възможност за връщане на предишна версия
 - Възможност администратор да изтрива избрани по-стари версии (освен текущата активна)

### Компоненти
- **Версионен контрол** - проследяване на промените
- **Diff инструмент** - визуализиране на разликите
- **История на редакциите** - списък с всички версии
- **API за управление на версиите** - REST ендпойнти за създаване, връщане и изтриване на версии

## Wiki media storage (MVP)

В допълнение към текстовото съдържание на статиите, Wiki модулът трябва да поддържа изображения (диаграми, скрийншотове и др.), които се вграждат в markdown съдържанието.

### Логика и физическо съхранение

- В **MVP** всички изображения за Wiki се съхраняват на **локална файлова система** на VPS машината, в директория/volume, споделен между:
  - reverse proxy слоя (Nginx), който сервира статика;
  - `wiki_service`, който записва/изтрива файлове при upload/delete.
- Структура на пътищата в този storage (концептуално):

  ```text
  <media_root>/wiki/<article_slug>/<filename.ext>
  например: /var/qa4free/media/wiki/manual-testing-intro/diagram-1.png
  ```

- За простота в MVP се приема, че `slug` е **стабилен идентификатор** на статията. Ако slug се промени, миграцията/преименуването на файловете се извършва ръчно или с помощен тул (post-MVP задача).

### Публични URL-и и Nginx конфигурация

- Публичните URL-и за изображенията имат формата:

  ```text
  /wiki/media/<article_slug>/<filename.ext>
  ```

- Nginx е конфигуриран така, че `location /wiki/media/` да сочи към файловата система под `<media_root>/wiki/`. По този начин frontend-ът може директно да вмъква тези URL-и в markdown съдържанието.

### Upload/Delete поведение (Admin)

- Upload на изображения се извършва през admin API:
  - `POST /api/admin/wiki/articles/{id}/media` (multipart/form-data с `file`).
  - `wiki_service` валидира типа (image/*) и размера на файла.
  - Файлът се записва под `<media_root>/wiki/<slug>/...` с нормализирано име (`filename`).
  - Отговорът връща структура `WikiMediaItem { filename, url }`, където `url` е директно използваем в markdown (напр. `![alt](/wiki/media/manual-testing-intro/diagram-1.png)`).

- Изтриване на изображения:
  - `DELETE /api/admin/wiki/articles/{id}/media/{filename}`.
  - `wiki_service` намира и изтрива съответния файл от `<media_root>/wiki/<slug>/`.
  - При успех връща HTTP 204.

### Бъдеща миграция към object storage (post-MVP)

- Архитектурата умишлено изолира media достъпа зад `wiki_service` и Nginx, за да позволи лесна миграция към object storage (напр. S3/Backblaze) в бъдеща версия:
  - Публичният път `/wiki/media/<slug>/<filename>` може да се запази и да сочи към CDN/object storage.
  - Само имплементацията на `WikiMediaItem` storage във `wiki_service` се сменя от локална файлова система към object storage SDK.
  - Съществуващите markdown линкове остават валидни.

## GDPR съответствие

### Събирани данни
- Име и имейл адрес (само за регистрирани потребители)
- История на действията (логване, достъп до страници)
- Устройство и браузър информация (анонимизирана)
- Интереси и поведение (агрегирани данни)

### Права на потребителите
- Право на достъп до личните данни
- Право на изтриване (right to be forgotten)
- Право на преносимост на данните
- Право на коригиране на неточни данни

### Имплементация
- Автоматично изтриване на данни след изтриване на акаунт
- API ендпойнти за експорт на лични данни
- Политика за съхранение на данни (30 дни след деактивиране на акаунта)
- Криптиране на чувствителни данни
- Публични статични страници „Privacy/GDPR“ и „Условия за ползване (Terms of Use)“, достъпни от footer-а на основните екрани и описващи обработката на данни и правилата за ползване.
- Регистрационна форма с задължителен checkbox „Съгласен съм с условията за ползване и политиката за поверителност“, който изисква изрично съгласие преди създаване на акаунт.

## Управление на потребителски данни

### Експорт на данни
- Генериране на архив с всички лични данни
- Включване на:
  - Профилна информация
  - История на действията
  - Тестови резултати
  - Предпочитания

### Изтриване на акаунт
- Анонимизиране на всички лични данни
- Запазване на анонимни данни за анализи
- Изтриване на чувствителни данни
- Потвърждение по имейл преди изтриване

### Технически детайли
- Асинхронна обработка на заявките
- Опашка за обработка на големи количества данни
- Логване на всички операции с данни
- Уведомяване на потребителя при завършване

## Технологичен стек

### Frontend
- **Next.js** (React) - за сървърно рендиране и статичен генериращ сайт
- **TypeScript** - за по-добра поддръжка на типовете
- **Tailwind CSS** - за стилизиране
- **Redux Toolkit** - за управление на състоянието
- **Axios** - за HTTP заявки
- **React Query** - за управление на данните и кеширане
- **next-i18next** - за управление на преводите и мултиезичност
- **next-seo** - за SEO оптимизация и управление на мета тагове

### Backend
- **NestJS** - основен фреймуърк за бекенд услугите
- **TypeScript** - за по-добра поддръжка на типовете
- **TypeORM** - за достъп до базата данни
- **JWT** - за автентикация
- **Swagger** - за API документация
- **Passport** - за автентикация и оторизация
- **Class-validator** - за валидация на входящите данни
- **i18n модул** - за управление на преводите и мултиезичност
- **Redis** - за кеширане и управление на сесии
- **RabbitMQ** - за асинхронни задачи, опашки и event-driven интеграции (бекграунд процеси, изпращане на имейли, обработка на метрики и др.)
- **TypeORM History** - за проследяване на промените в базата данни
- **Node-cron** - за планирани задачи (изтриване на данни, архивиране)
- **Bcryptjs** - за криптиране на пароли
- **Helmet** - за защита на HTTP заглавията
- **Rate limiting** - за защита срещу брут форс атаки

### Бази данни
- **PostgreSQL** - основна база данни
- **Redis** - за кеширане и управление на сесии

### Инфраструктура
- **Docker** - за контейнеризация
- **Docker Compose** - за управление на мулти-контейнерни приложения
- **Nginx** - като reverse proxy
- **Let's Encrypt** - за SSL сертификати

Цялата система се деплойва като набор от Docker контейнери върху една VPS машина:
- отделен контейнер за frontend приложението (Next.js);
- отделни контейнери за бекенд услугите (API gateway, auth, wiki, practical env, training API, metrics);
- отделни контейнери за инфраструктурните компоненти (PostgreSQL, Redis);
- отделен контейнер за message broker (RabbitMQ) за асинхронни задачи и обработка на опашки.

### Мониторинг и логване
- **Winston** - за логване
- **Prometheus** + **Grafana** - за метрики
- **Sentry** - за проследяване на грешки

## Инфраструктура

### Хостинг
- **VPS** в Contabo с конфигурация:
  - 6 vCPU ядра
  - 12GB RAM
  - 100GB NVMe дисково пространство
  - 300 Mbit/s мрежов порт
  - Неограничен трафик

### Домейн
- **qa4free.com** - основен домейн

### DevOps насоки за конфигурация на VPS (MVP)

- Използване на един основен `docker-compose.yml` за продукционната среда,
  съдържащ всички услуги (frontend, backend, PostgreSQL, Redis, RabbitMQ,
  reverse proxy).
- Конфигуриране на именувани Docker volumes за персистентни данни (най-малко
  за PostgreSQL и, при нужда, за RabbitMQ).
- Задаване на разумни лимити за ресурси на контейнерите (CPU/RAM) в
  `docker-compose.yml`, така че да не се изчерпват 6 vCPU / 12GB RAM на VPS.
- Настройка на healthcheck-и за основните услуги (API Gateway, auth,
  PostgreSQL, Redis, RabbitMQ), за да може orchestration слоят да открива
  и рестартира проблемни контейнери.
- Централизиране на логовете чрез писане към stdout/stderr на контейнерите и
  събиране през Docker logging драйвери или външни инструменти.
- Разделяне на конфигурацията по среди чрез `.env` файлове (напр.
  `.env.dev`, `.env.prod`) и никога да не се комитват реални секрети в
  репото.
- Регулярен backup на PostgreSQL данните (cron job или отделен backup
  контейнер), съхраняван на външно хранилище (например object storage).

## Безопасност
- **Криптиране** - Всички връзки са криптирани с **HTTPS**
- **Автентикация** - JWT токени с краен срок на валидност и възможност за отнемане
- **Валидация** - Строга валидация на всички входящи данни
- **Защита срещу атаки**:
  - **CSRF** - SameSite cookies и CSRF токени
  - **XSS** - Автоматично екраниране на изходните данни
  - **SQL инжекции** - Параметризирани заявки и ORM
  - **Защита срещу брут форс**:
    - Rate limiting за всички потребители (по IP/endpoint) и допълнителни бизнес-специфични лимити – напр. ограничаване на броя успешни потвърждения на смяна на email за даден акаунт (3 потвърждения за 24 часа), с цел да се намалят злоупотреби и натоварване на имейл канала
    - Временни банове на IP адреси с твърде много грешни опити
    - Автоматично отключване след определен период
    - Обаждането на администратор при съмнителна активност
- **Защита на данните**:
  - Криптиране на чувствителни данни в базата
  - Хеширане на пароли с bcrypt
  - Регулярни архиви на данните
- **Одит и логване**:
  - Логване на всички критични действия
  - Проследяване на потребителските сесии
  - Сигнали за подозрителна активност
- **Поддръжка и актуализации**:
  - Редовни ъпдейти на всички зависимости
  - Сканиране за уязвимости
  - План за реакция при инциденти

## Практическа среда

### Компоненти (MVP)
1. **UI demo страници (Sandbox UI)**
   - Страници във frontend приложението с богата комбинация от HTML елементи
     (input полета, drop-down списъци, radio бутони, checkbox-и, таблици и др.).
   - Няма специфична backend бизнес логика – целта е упражнения по manual и
     UI automation тестване.

2. **Training API (Sandbox API)**
   - Отделна backend услуга `training-api` в отделен Docker контейнер,
     достъпна през API Gateway.
   - MVP версията включва минимален набор от ендпойнти за упражнения
     (напр. `GET /api/training/ping` и `POST /api/training/echo`) за позитивни
     и негативни тестове.
   - В бъдещи версии Training API може да бъде разширен с по-смислени CRUD/
     бизнес сценарии за по-напреднали automation упражнения.

3. **Автоматично оценяване и изпълнение на код (post-MVP)**
   - Концептуално се предвижда по-сложен изпълнител на задачи и изолирана
     Docker "пясъчник" среда за изпълнение на код с ограничени ресурси,
     автоматично почистване и автоматично оценяване на резултатите.
   - Тези компоненти се разглеждат като бъдещи разширения и **не са част от
     MVP обхвата**.

### Интеграции
- **Wiki услуга** - за достъп до учебни материали
- **Услуга за автентикация** - за валидация на достъпа
- **Метрики** - за агрегирани данни (посещения, най-преглеждани страници, технически показатели). Проследяване на индивидуален учебен напредък се планира за бъдещия „exams“ модул и не е част от MVP.

## Система за метрики и анализи

### Събирани данни
1. **Потребителско поведение**
   - Време, прекарано на страници
   - Натискани бутони и линкове
   - Пътеки на навигация

2. **Учебен напредък (post-MVP, „exams“ модул)**
   - Метрики за завършени тестове/задачи и резултати **не са част от текущото MVP** и ще се добавят в бъдеща версия.

3. **Системна производителност**
   - Време за зареждане на страници
   - Грешки и проблеми
   - Натоварване на сървъра

### Визуализация
- Табло за администраторите (агрегирани метрики за потребители, Wiki и натоварване).
- (Post-MVP) Индивидуален прогрес за потребителите и по-детайлни учебни анализи.
- Агрегирани анализи за подобряване на съдържанието.

## Демо среда за практически задачи

### Архитектура (MVP)
1. **Sandbox UI**
   - Част от основното Next.js frontend приложение.
   - Статични страници/компоненти с разнообразни HTML елементи за
     упражнения по manual и UI automation тестване.

2. **Training API**
   - Самостоятелен NestJS сервиз `training-api` зад API Gateway.
   - Минимален набор от ендпойнти (ping/echo) за основни позитивни и
     негативни сценарии.

3. **Интеграции**
   - Training API е документиран със Swagger/OpenAPI и достъпен през
     `/api/training/*` за нуждите на automation QA упражнения.

### Бъдещи разширения на контейнеризацията (post-MVP)
1. **Пер-сесия Docker пясъчник**
   - В бъдещи версии може да се добави отделен Docker контейнер на сесия
     за изпълнение на код, с ограничени ресурси и автоматично почистване
     след използване.
   - Поддръжка на допълнителни езици за програмиране и по-сложни
     сценарии за автоматично оценяване.

### Диаграма на последователност за изпълнение на задачи

```mermaid
sequenceDiagram
    participant Потребител
    participant Frontend
    participant API Gateway
    participant Практическа среда
    participant Sandbox
    participant База данни

    Потребител->>Frontend: Стартира задача
    Frontend->>API Gateway: GET /api/tasks/{id}
    API Gateway->>Практическа среда: Заявка за задача
    Практическа среда->>База данни: Вземи задача
    Практическа среда-->>API Gateway: Връща задача
    API Gateway-->>Frontend: Показва задача
    
    Потребител->>Frontend: Изпраща решение
    Frontend->>API Gateway: POST /api/tasks/{id}/submit
    API Gateway->>Практическа среда: Изпраща решение
    Практическа среда->>Пясъчник: Стартира изпълнение
    Пясъчник-->>Практическа среда: Връща резултати
    Практическа среда->>База данни: Запазва резултати
    Практическа среда-->>API Gateway: Връща резултати
    API Gateway-->>Frontend: Показва резултати
```

## Масштабируемост
- Хоризонтално маштабиране на отделните услуги
- Кеширане на често използвани данни с Redis
- Възможност за добавяне на допълнителни инстанции на услугите при необходимост
- Оптимизирани заявки към базата данни и ефективно използване на индекси

## Заключение

### Ключови характеристики на архитектурата
- **Микросервисна архитектура** с ясно дефинирани граници между компонентите
- **Висока достъпност** чрез хоризонтално мащабиране и излишък
- **Сигурност** чрез модерни практики за защита на данните и потребителската поверителност
- **Гъвкавост** за бъдещо разширяване на функционалностите
- **Производителност** чрез ефективно използване на кеширане и оптимизирани заявки

### Следващи стъпки
1. Детайлно проектиране на базата данни
2. Имплементация на основните сервизи
3. Разработка на потребителския интерфейс
4. Интеграционно тестване
5. Настройка на инфраструктурата и деплойване

### Ограничения и бъдещи разширения
- В бъдеще може да се добави поддръжка на още езици
- Възможност за интеграция с допълнителни услуги (например платформи за онлайн обучение)
- Разширяване на функционалностите за анализ на данните
- Подобряване на системата за модерация на съдържанието
