import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import {
  ValidationPipe,
  ValidationError,
  BadRequestException,
  ForbiddenException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as cookieParser from 'cookie-parser';
import { Request, Response, NextFunction } from 'express';
import * as helmet from 'helmet';
import * as fs from 'fs';
import * as path from 'path';

async function bootstrap() {
  // Настройка за HTTPS/SSL
  // Проверяваме дали сме в production режим и дали имаме сертификати
  const isProduction = process.env.NODE_ENV === 'production';

  // Конфигурация за SSL/TLS
  let httpsOptions = {};

  if (isProduction) {
    try {
      // Пътища към SSL сертификатите
      const sslKeyPath =
        process.env.SSL_KEY_PATH ||
        path.resolve(__dirname, '../ssl/private-key.pem');
      const sslCertPath =
        process.env.SSL_CERT_PATH ||
        path.resolve(__dirname, '../ssl/certificate.pem');
      const sslCaPath =
        process.env.SSL_CA_PATH || path.resolve(__dirname, '../ssl/ca.pem');

      // Проверка за съществуване на файловете
      if (fs.existsSync(sslKeyPath) && fs.existsSync(sslCertPath)) {
        httpsOptions = {
          key: fs.readFileSync(sslKeyPath),
          cert: fs.readFileSync(sslCertPath),
          // Ако имаме CA сертификат, също го зареждаме
          ...(fs.existsSync(sslCaPath) && { ca: fs.readFileSync(sslCaPath) }),
        };
        console.log('SSL сертификатите са заредени успешно');
      } else {
        console.warn('SSL сертификатите не са намерени на указаните пътища');
      }
    } catch (error) {
      console.error('Грешка при зареждане на SSL сертификатите:', error);
    }
  }

  // Създаваме приложението със съпорт за HTTPS, ако имаме настройки за SSL
  const app = await NestFactory.create(AppModule, {
    httpsOptions:
      Object.keys(httpsOptions).length > 0 ? httpsOptions : undefined,
  });
  const configService = app.get(ConfigService);

  // Apply Helmet middleware with CSP headers for enhanced security
  app.use(
    helmet.default({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: [
            "'self'",
            "'unsafe-inline'",
            "'unsafe-eval'",
            'https://cdn.jsdelivr.net',
          ],
          styleSrc: ["'self'", "'unsafe-inline'", 'https://cdn.jsdelivr.net'],
          imgSrc: ["'self'", 'data:', 'https://*'],
          connectSrc: ["'self'", 'https://*'],
          fontSrc: ["'self'", 'https://cdn.jsdelivr.net'],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'self'"],
          // Report violations to this endpoint (optional)
          reportUri: '/csp-violation-report',
          // Upgrade insecure requests directive
          upgradeInsecureRequests:
            process.env.NODE_ENV === 'production' ? [] : null,
        },
      },
      // Disable X-Powered-By header to avoid disclosing technology stack
      hidePoweredBy: true,
      // Enable strict transport security for secure connections
      strictTransportSecurity:
        process.env.NODE_ENV === 'production'
          ? { maxAge: 63072000, includeSubDomains: true }
          : false,
      // Prevent browser from doing MIME type sniffing
      noSniff: true,
      // Prevent click-jacking attacks by denying iframe embedding
      frameguard: { action: 'deny' },
      // Prevent XSS attacks by setting proper headers
      xssFilter: true,
    }),
  );

  // Use cookie parser to support cookie-based CSRF tokens
  app.use(cookieParser());

  // CSRF error handling
  app.use(
    (
      err: Error & { code?: string },
      req: Request,
      res: Response,
      next: NextFunction,
    ) => {
      if (err && err.code === 'EBADCSRFTOKEN') {
        // CSRF token validation failed
        throw new ForbiddenException('Invalid or missing CSRF token');
      }
      next(err);
    },
  );

  // Add CSRF token to response headers for frontend access
  app.use(
    (
      req: Request & { csrfToken?: () => string },
      res: Response,
      next: NextFunction,
    ) => {
      // If the request has a CSRF token generated by csurf, expose it
      if (req.csrfToken && typeof req.csrfToken === 'function') {
        try {
          const token = req.csrfToken();
          res.setHeader('X-CSRF-Token', token);
        } catch {
          // CSRF might not be initialized on this route
        }
      }
      next();
    },
  );

  // Enable validation
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
      exceptionFactory: (validationErrors: ValidationError[] = []) => {
        return new BadRequestException(
          validationErrors.map((error) => ({
            field: error.property,
            error: Object.values(error.constraints || {}).join(', '),
          })),
        );
      },
    }),
  );

  // Enable CORS with credentials support (needed for CSRF cookies)
  app.enableCors({
    origin: configService.get<string>('CORS_ORIGIN', '*'),
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    credentials: true,
  });

  // Setup Swagger documentation
  const swaggerConfig = new DocumentBuilder()
    .setTitle('Analytics API')
    .setDescription('The Analytics API for the QA-4-Free platform')
    .setVersion('1.0')
    .addBearerAuth()
    .build();

  const document = SwaggerModule.createDocument(app, swaggerConfig);
  SwaggerModule.setup('api/docs', app, document);

  // Get port from environment variable or use default 3105
  const port = configService.get<number>('PORT', 3105);
  const host = configService.get<string>('HOST', '127.0.0.1');

  // Log whether we're running in HTTPS or HTTP mode
  const protocol = Object.keys(httpsOptions).length > 0 ? 'HTTPS' : 'HTTP';
  console.log(`Starting server in ${protocol} mode`);

  await app.listen(port, host);

  // Get the server URL
  const baseUrl = await app.getUrl();
  const swaggerPath = '/api/docs';

  console.log(`Application is running on: ${baseUrl}`);
  console.log(
    `Swagger documentation is available at: ${baseUrl}${swaggerPath}`,
  );
}

bootstrap().catch((err) => {
  console.error('Error starting the application:', err);
  process.exit(1);
});
