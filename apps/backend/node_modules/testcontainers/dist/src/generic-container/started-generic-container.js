"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartedGenericContainer = void 0;
const inspect_container_1 = require("../docker/functions/container/inspect-container");
const bound_ports_1 = require("../bound-ports");
const logger_1 = require("../logger");
const remove_container_1 = require("../docker/functions/container/remove-container");
const exec_container_1 = require("../docker/functions/container/exec-container");
const container_logs_1 = require("../docker/functions/container/container-logs");
const stopped_generic_container_1 = require("./stopped-generic-container");
const stop_container_1 = require("../docker/functions/container/stop-container");
const restart_container_1 = require("../docker/functions/container/restart-container");
const wait_for_container_1 = require("../wait-for-container");
const docker_client_1 = require("../docker/client/docker-client");
const async_lock_1 = __importDefault(require("async-lock"));
const get_container_archive_1 = require("../docker/functions/container/get-container-archive");
const archiver_1 = __importDefault(require("archiver"));
const put_container_archive_1 = require("../docker/functions/container/put-container-archive");
class StartedGenericContainer {
    constructor(container, host, inspectResult, boundPorts, name, waitStrategy) {
        this.container = container;
        this.host = host;
        this.inspectResult = inspectResult;
        this.boundPorts = boundPorts;
        this.name = name;
        this.waitStrategy = waitStrategy;
        this.stopContainerLock = new async_lock_1.default();
    }
    stop(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.stopContainerLock.acquire("stop", () => __awaiter(this, void 0, void 0, function* () {
                if (this.stoppedContainer) {
                    return this.stoppedContainer;
                }
                this.stoppedContainer = yield this.stopContainer(options);
                return this.stoppedContainer;
            }));
        });
    }
    restart(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedOptions = Object.assign({ timeout: 0 }, options);
            logger_1.log.info(`Restarting container...`, { containerId: this.container.id });
            yield (0, restart_container_1.restartContainer)(this.container, resolvedOptions);
            const { hostIps } = yield (0, docker_client_1.getDockerClient)();
            this.inspectResult = yield (0, inspect_container_1.inspectContainer)(this.container);
            const startTime = this.inspectResult.state.startedAt;
            if (logger_1.containerLog.enabled()) {
                (yield (0, container_logs_1.containerLogs)(this.container, { since: startTime }))
                    .on("data", (data) => logger_1.containerLog.trace(data.trim(), { containerId: this.container.id }))
                    .on("err", (data) => logger_1.containerLog.error(data.trim(), { containerId: this.container.id }));
            }
            this.boundPorts = bound_ports_1.BoundPorts.fromInspectResult(hostIps, this.inspectResult).filter(Array.from(this.boundPorts.iterator()).map((port) => port[0]));
            yield (0, wait_for_container_1.waitForContainer)(this.container, this.waitStrategy, this.boundPorts, startTime);
            logger_1.log.info(`Restarted container`, { containerId: this.container.id });
        });
    }
    stopContainer(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Stopping container...`, { containerId: this.container.id });
            if (this.containerIsStopping) {
                yield this.containerIsStopping();
            }
            const resolvedOptions = Object.assign({ remove: true, timeout: 0, removeVolumes: true }, options);
            yield (0, stop_container_1.stopContainer)(this.container, { timeout: resolvedOptions.timeout });
            if (resolvedOptions.remove) {
                yield (0, remove_container_1.removeContainer)(this.container, { removeVolumes: resolvedOptions.removeVolumes });
            }
            logger_1.log.info(`Stopped container`, { containerId: this.container.id });
            if (this.containerIsStopped) {
                yield this.containerIsStopped();
            }
            return new stopped_generic_container_1.StoppedGenericContainer(this.container);
        });
    }
    getHost() {
        return this.host;
    }
    getFirstMappedPort() {
        return this.boundPorts.getFirstBinding();
    }
    getMappedPort(port) {
        return this.boundPorts.getBinding(port);
    }
    getId() {
        return this.container.id;
    }
    getName() {
        return this.name;
    }
    getLabels() {
        return this.inspectResult.labels;
    }
    getNetworkNames() {
        return Object.keys(this.inspectResult.networkSettings);
    }
    getNetworkId(networkName) {
        return this.inspectResult.networkSettings[networkName].networkId;
    }
    getIpAddress(networkName) {
        return this.inspectResult.networkSettings[networkName].ipAddress;
    }
    copyFilesToContainer(filesToCopy) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Copying files to container...`, { containerId: this.container.id });
            const tar = (0, archiver_1.default)("tar");
            filesToCopy.forEach(({ source, target }) => tar.file(source, { name: target }));
            tar.finalize();
            yield (0, put_container_archive_1.putContainerArchive)({ container: this.container, stream: tar, containerPath: "/" });
            logger_1.log.debug(`Copied files to container`, { containerId: this.container.id });
        });
    }
    copyDirectoriesToContainer(directoriesToCopy) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Copying directories to container...`, { containerId: this.container.id });
            const tar = (0, archiver_1.default)("tar");
            directoriesToCopy.forEach(({ source, target }) => tar.directory(source, target));
            tar.finalize();
            yield (0, put_container_archive_1.putContainerArchive)({ container: this.container, stream: tar, containerPath: "/" });
            logger_1.log.debug(`Copied directories to container`, { containerId: this.container.id });
        });
    }
    copyContentToContainer(contentsToCopy) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Copying content to container...`, { containerId: this.container.id });
            const tar = (0, archiver_1.default)("tar");
            contentsToCopy.forEach(({ content, target }) => tar.append(content, { name: target }));
            tar.finalize();
            yield (0, put_container_archive_1.putContainerArchive)({ container: this.container, stream: tar, containerPath: "/" });
            logger_1.log.debug(`Copied content to container`, { containerId: this.container.id });
        });
    }
    copyArchiveFromContainer(path) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Copying archive "${path}" from container...`, { containerId: this.container.id });
            const stream = yield (0, get_container_archive_1.getContainerArchive)({ container: this.container, path: path });
            logger_1.log.debug(`Copied archive "${path}" from container`, { containerId: this.container.id });
            return stream;
        });
    }
    exec(command) {
        return __awaiter(this, void 0, void 0, function* () {
            const { dockerode, containerRuntime } = yield (0, docker_client_1.getDockerClient)();
            const commandArr = Array.isArray(command) ? command : command.split(" ");
            const commandStr = commandArr.join(" ");
            logger_1.log.debug(`Executing command "${commandStr}"...`, { containerId: this.container.id });
            const output = yield (0, exec_container_1.execContainer)(dockerode, containerRuntime, this.container, commandArr);
            logger_1.log.debug(`Executed command "${commandStr}"...`, { containerId: this.container.id });
            return output;
        });
    }
    logs() {
        return (0, container_logs_1.containerLogs)(this.container);
    }
}
exports.StartedGenericContainer = StartedGenericContainer;
