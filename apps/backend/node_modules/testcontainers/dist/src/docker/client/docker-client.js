"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDockerClient = void 0;
const dockerode_1 = __importDefault(require("dockerode"));
const logger_1 = require("../../logger");
const lookup_host_ips_1 = require("../lookup-host-ips");
const system_info_1 = require("../../system-info");
const rootless_unix_socket_strategy_1 = require("./strategy/rootless-unix-socket-strategy");
const stream_utils_1 = require("../../stream-utils");
const stream_1 = require("stream");
const resolve_host_1 = require("../resolve-host");
const configuration_strategy_1 = require("./strategy/configuration-strategy");
const unix_socket_strategy_1 = require("./strategy/unix-socket-strategy");
const npipe_socket_strategy_1 = require("./strategy/npipe-socket-strategy");
const testcontainers_host_strategy_1 = require("./strategy/testcontainers-host-strategy");
const uuid_1 = require("../../uuid");
const file_lock_1 = require("../../file-lock");
const reaper_1 = require("../../reaper");
const docker_compose_client_1 = require("../../docker-compose/docker-compose-client");
let dockerClient;
const strategies = [
    new testcontainers_host_strategy_1.TestcontainersHostStrategy(),
    new configuration_strategy_1.ConfigurationStrategy(),
    new unix_socket_strategy_1.UnixSocketStrategy(),
    new rootless_unix_socket_strategy_1.RootlessUnixSocketStrategy(),
    new npipe_socket_strategy_1.NpipeSocketStrategy(),
];
function getDockerClient() {
    return __awaiter(this, void 0, void 0, function* () {
        if (dockerClient) {
            return dockerClient;
        }
        for (const strategy of strategies) {
            try {
                const initialisedDockerClient = yield initialiseStrategy(strategy);
                if (!initialisedDockerClient) {
                    continue;
                }
                dockerClient = initialisedDockerClient;
                logDockerClient(strategy.getName(), dockerClient);
                return dockerClient;
            }
            catch (err) {
                logger_1.log.warn(`Docker client strategy "${strategy.getName()}" threw: "${err}"`);
            }
        }
        throw new Error("No Docker client strategy found");
    });
}
exports.getDockerClient = getDockerClient;
function initialiseStrategy(strategy) {
    return __awaiter(this, void 0, void 0, function* () {
        const partialDockerClient = yield tryToCreateDockerClient(strategy);
        if (!partialDockerClient) {
            return;
        }
        yield (0, file_lock_1.withFileLock)("tc.lock", () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const dockerode = new dockerode_1.default(partialDockerClient.dockerOptions);
            const containers = yield dockerode.listContainers();
            const reaperContainer = containers.find((container) => container.Labels["org.testcontainers.ryuk"] === "true");
            const sessionId = (_a = reaperContainer === null || reaperContainer === void 0 ? void 0 : reaperContainer.Labels["org.testcontainers.session-id"]) !== null && _a !== void 0 ? _a : new uuid_1.RandomUuid().nextUuid();
            const dockerOptions = Object.assign(Object.assign({}, partialDockerClient.dockerOptions), { headers: Object.assign(Object.assign({}, partialDockerClient.dockerOptions.headers), { "x-tc-sid": sessionId }) });
            dockerClient = Object.assign(Object.assign({}, partialDockerClient), { sessionId,
                dockerOptions, dockerode: new dockerode_1.default(dockerOptions) });
            yield (0, reaper_1.startReaper)(dockerClient, sessionId, reaperContainer);
            yield (0, reaper_1.registerSessionIdForCleanup)(sessionId);
        }));
        return dockerClient;
    });
}
function tryToCreateDockerClient(strategy) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (strategy.init) {
            yield strategy.init();
        }
        if (strategy.isApplicable()) {
            const dockerClientStrategyResult = yield strategy.getDockerClient();
            logger_1.log.debug(`Testing Docker client strategy "${strategy.getName()}" with URI "${dockerClientStrategyResult.uri}"...`);
            const dockerode = new dockerode_1.default(dockerClientStrategyResult.dockerOptions);
            if (yield isDockerDaemonReachable(dockerode)) {
                const info = yield (0, system_info_1.getSystemInfo)(dockerode);
                const containerRuntime = dockerClientStrategyResult.uri.includes("podman.sock")
                    ? "podman"
                    : "docker";
                const host = yield (0, resolve_host_1.resolveHost)(dockerode, containerRuntime, info.dockerInfo.indexServerAddress, dockerClientStrategyResult.uri, dockerClientStrategyResult.allowUserOverrides);
                const hostIps = yield (0, lookup_host_ips_1.lookupHostIps)(host);
                const dockerComposeClient = yield (0, docker_compose_client_1.getDockerComposeClient)((_a = info.dockerComposeInfo) === null || _a === void 0 ? void 0 : _a.compatability);
                return Object.assign(Object.assign({}, dockerClientStrategyResult), { containerRuntime,
                    host,
                    hostIps,
                    info,
                    dockerode,
                    dockerComposeClient });
            }
            else {
                logger_1.log.warn(`Docker client strategy "${strategy.getName()}" does not work`);
            }
        }
    });
}
function isDockerDaemonReachable(dockerode) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const response = yield dockerode.ping();
            return (yield (0, stream_utils_1.streamToString)(stream_1.Readable.from(response))) === "OK";
        }
        catch (err) {
            logger_1.log.warn(`Docker daemon is not reachable: "${err}"`);
            return false;
        }
    });
}
function logDockerClient(strategyName, { host, hostIps }) {
    if (!logger_1.log.enabled()) {
        return;
    }
    const formattedHostIps = hostIps.map((hostIp) => hostIp.address).join(", ");
    logger_1.log.info(`Docker client strategy "${strategyName}" works, ${host} (${formattedHostIps})`);
}
