"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startReaper = exports.registerComposeProjectForCleanup = exports.registerSessionIdForCleanup = void 0;
const net_1 = require("net");
const logger_1 = require("./logger");
const generic_container_1 = require("./generic-container/generic-container");
const images_1 = require("./images");
const labels_1 = require("./labels");
const wait_1 = require("./wait-strategy/wait");
const retry_strategy_1 = require("./retry-strategy");
const remote_docker_unix_socket_path_1 = require("./docker/remote-docker-unix-socket-path");
const docker_client_1 = require("./docker/client/docker-client");
const isReaperEnabled = process.env.TESTCONTAINERS_RYUK_DISABLED !== "true";
let reaper;
function registerSessionIdForCleanup(sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!reaper) {
            yield (0, docker_client_1.getDockerClient)();
        }
        (yield reaper).addSession(sessionId);
    });
}
exports.registerSessionIdForCleanup = registerSessionIdForCleanup;
function registerComposeProjectForCleanup(project) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!reaper) {
            yield (0, docker_client_1.getDockerClient)();
        }
        (yield reaper).addProject(project);
    });
}
exports.registerComposeProjectForCleanup = registerComposeProjectForCleanup;
function startReaper(dockerClient, sessionId, existingReaperContainer) {
    return __awaiter(this, void 0, void 0, function* () {
        reaper = !isReaperEnabled
            ? yield createDisabledReaper()
            : existingReaperContainer
                ? yield useExistingReaper(dockerClient, sessionId, existingReaperContainer)
                : yield createNewReaper(dockerClient, sessionId);
    });
}
exports.startReaper = startReaper;
function createDisabledReaper() {
    return __awaiter(this, void 0, void 0, function* () {
        return new DisabledReaper();
    });
}
function useExistingReaper(dockerClient, sessionId, reaperContainer) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.log.debug(`Reusing existing Reaper for session "${sessionId}"...`);
        const reaperPort = getReaperPublicPort(reaperContainer);
        const socket = yield connectToReaperSocket(dockerClient.host, reaperPort, sessionId, reaperContainer.Id);
        return new RealReaper(sessionId, socket);
    });
}
function getReaperPublicPort(reaperContainer) {
    var _a;
    const port = (_a = reaperContainer.Ports.find((port) => port.PrivatePort == 8080)) === null || _a === void 0 ? void 0 : _a.PublicPort;
    if (!port) {
        throw new Error("Expected Reaper to map exposed port 8080");
    }
    return port;
}
function createNewReaper(dockerClient, sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
        const remoteDockerUnixSocketPath = (0, remote_docker_unix_socket_path_1.getRemoteDockerUnixSocketPath)(dockerClient);
        logger_1.log.debug(`Creating new Reaper for session "${sessionId}" with socket path "${remoteDockerUnixSocketPath}"...`);
        const startedContainer = yield createAndStartReaperContainer(sessionId, remoteDockerUnixSocketPath);
        const containerId = startedContainer.getId();
        const host = startedContainer.getHost();
        const port = startedContainer.getMappedPort(8080);
        const socket = yield connectToReaperSocket(host, port, sessionId, containerId);
        return new RealReaper(sessionId, socket);
    });
}
function createAndStartReaperContainer(sessionId, socketPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const exposedPort = process.env["TESTCONTAINERS_RYUK_PORT"]
            ? { container: 8080, host: Number(process.env["TESTCONTAINERS_RYUK_PORT"]) }
            : 8080;
        const container = new generic_container_1.GenericContainer(images_1.REAPER_IMAGE)
            .withName(`testcontainers-ryuk-${sessionId}`)
            .withExposedPorts(exposedPort)
            .withBindMounts([{ source: socketPath, target: "/var/run/docker.sock" }])
            .withWaitStrategy(wait_1.Wait.forLogMessage(/.+ Started!/));
        if (process.env.TESTCONTAINERS_RYUK_PRIVILEGED === "true") {
            container.withPrivilegedMode();
        }
        return yield container.start();
    });
}
function connectToReaperSocket(host, port, sessionId, containerId) {
    return __awaiter(this, void 0, void 0, function* () {
        const retryResult = yield new retry_strategy_1.IntervalRetryStrategy(1000).retryUntil((attempt) => {
            return new Promise((resolve) => {
                logger_1.log.debug(`Connecting to Reaper (attempt ${attempt + 1}) on "${host}:${port}"...`, { containerId });
                const socket = new net_1.Socket();
                socket
                    .unref()
                    .on("timeout", () => logger_1.log.error(`Reaper ${containerId} socket timed out`))
                    .on("error", (err) => logger_1.log.error(`Reaper ${containerId} socket error: ${err}`))
                    .on("close", (hadError) => {
                    if (hadError) {
                        logger_1.log.error(`Connection to Reaper closed with error`, { containerId });
                    }
                    else {
                        logger_1.log.warn(`Connection to Reaper closed`, { containerId });
                    }
                    resolve(undefined);
                })
                    .connect(port, host, () => {
                    logger_1.log.debug(`Connected to Reaper`, { containerId });
                    resolve(socket);
                });
            });
        }, (result) => result !== undefined, () => {
            const message = `Failed to connect to Reaper`;
            logger_1.log.error(message, { containerId });
            return new Error(message);
        }, 4000);
        if (retryResult instanceof net_1.Socket) {
            return retryResult;
        }
        else {
            throw retryResult;
        }
    });
}
class RealReaper {
    constructor(sessionId, socket) {
        this.sessionId = sessionId;
        this.socket = socket;
    }
    addSession(sessionId) {
        this.socket.write(`label=${labels_1.LABEL_TESTCONTAINERS_SESSION_ID}=${sessionId}\r\n`);
    }
    addProject(projectName) {
        this.socket.write(`label=com.docker.compose.project=${projectName}\r\n`);
    }
}
class DisabledReaper {
    addSession() {
        // noop
    }
    addProject() {
        // noop
    }
}
