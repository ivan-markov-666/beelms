"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoppedSeleniumRecordingContainer = exports.StartedSeleniumRecordingContainer = exports.SeleniumRecordingContainer = exports.StoppedSeleniumContainer = exports.StartedSeleniumContainer = exports.SeleniumContainer = exports.SELENIUM_VIDEO_IMAGE = void 0;
const generic_container_1 = require("../../generic-container/generic-container");
const abstract_started_container_1 = require("../abstract-started-container");
const wait_1 = require("../../wait-strategy/wait");
const abstract_stopped_container_1 = require("../abstract-stopped-container");
const network_1 = require("../../network");
const logger_1 = require("../../logger");
const promises_1 = require("fs/promises");
const tmp_1 = __importDefault(require("tmp"));
const tar_fs_1 = __importDefault(require("tar-fs"));
const path_1 = __importDefault(require("path"));
const SELENIUM_PORT = 4444;
const VNC_PORT = 5900;
const SELENIUM_NETWORK_ALIAS = "selenium";
exports.SELENIUM_VIDEO_IMAGE = "selenium/video:ffmpeg-4.3.1-20230508";
class SeleniumContainer extends generic_container_1.GenericContainer {
    constructor(image = "selenium/standalone-chrome:112.0") {
        super(image);
    }
    beforeContainerStarted() {
        return __awaiter(this, void 0, void 0, function* () {
            this.withExposedPorts(SELENIUM_PORT, VNC_PORT)
                .withSharedMemorySize(2 * 1024 * 1024 * 1024)
                .withWaitStrategy(wait_1.Wait.forAll([
                wait_1.Wait.forListeningPorts(),
                wait_1.Wait.forHttp("/wd/hub/status", SELENIUM_PORT).forResponsePredicate((response) => {
                    try {
                        return JSON.parse(response).value.ready;
                    }
                    catch (_a) {
                        return false;
                    }
                }),
            ]));
        });
    }
    withRecording() {
        return new SeleniumRecordingContainer(this.image);
    }
    start() {
        const _super = Object.create(null, {
            start: { get: () => super.start }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return new StartedSeleniumContainer(yield _super.start.call(this));
        });
    }
}
exports.SeleniumContainer = SeleniumContainer;
class StartedSeleniumContainer extends abstract_started_container_1.AbstractStartedContainer {
    constructor(startedTestContainer) {
        super(startedTestContainer);
        this.serverUrl = `http://${this.getHost()}:${this.getMappedPort(4444)}/wd/hub`;
    }
    getServerUrl() {
        return this.serverUrl;
    }
    stop(options) {
        const _super = Object.create(null, {
            stop: { get: () => super.stop }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return new StoppedSeleniumContainer(yield _super.stop.call(this, options));
        });
    }
}
exports.StartedSeleniumContainer = StartedSeleniumContainer;
class StoppedSeleniumContainer extends abstract_stopped_container_1.AbstractStoppedContainer {
    constructor(stoppedSeleniumContainer) {
        super(stoppedSeleniumContainer);
        this.stoppedSeleniumContainer = stoppedSeleniumContainer;
    }
}
exports.StoppedSeleniumContainer = StoppedSeleniumContainer;
class SeleniumRecordingContainer extends SeleniumContainer {
    constructor(image) {
        super(image);
    }
    start() {
        const _super = Object.create(null, {
            start: { get: () => super.start }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const network = yield new network_1.Network().start();
            this.withNetwork(network);
            this.withNetworkAliases(SELENIUM_NETWORK_ALIAS);
            const startedSeleniumContainer = yield _super.start.call(this);
            const startedFfmpegContainer = yield new generic_container_1.GenericContainer(exports.SELENIUM_VIDEO_IMAGE)
                .withNetwork(network)
                .withEnvironment({ DISPLAY_CONTAINER_NAME: SELENIUM_NETWORK_ALIAS })
                .withWaitStrategy(wait_1.Wait.forLogMessage(/.*video-recording entered RUNNING state.*/))
                .start();
            return new StartedSeleniumRecordingContainer(startedSeleniumContainer, startedFfmpegContainer, network);
        });
    }
}
exports.SeleniumRecordingContainer = SeleniumRecordingContainer;
class StartedSeleniumRecordingContainer extends StartedSeleniumContainer {
    constructor(startedSeleniumContainer, startedFfmpegContainer, network) {
        super(startedSeleniumContainer);
        this.startedFfmpegContainer = startedFfmpegContainer;
        this.network = network;
    }
    stop(options) {
        const _super = Object.create(null, {
            stop: { get: () => super.stop }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const stoppedSeleniumContainer = yield _super.stop.call(this, options);
            const stoppedFfmpegContainer = yield this.startedFfmpegContainer.stop({ remove: false, timeout: 60000 });
            yield this.network.stop();
            return new StoppedSeleniumRecordingContainer(stoppedSeleniumContainer, stoppedFfmpegContainer);
        });
    }
}
exports.StartedSeleniumRecordingContainer = StartedSeleniumRecordingContainer;
class StoppedSeleniumRecordingContainer extends StoppedSeleniumContainer {
    constructor(stoppedSeleniumContainer, stoppedFfmpegContainer) {
        super(stoppedSeleniumContainer);
        this.stoppedFfmpegContainer = stoppedFfmpegContainer;
    }
    saveRecording(target) {
        return __awaiter(this, void 0, void 0, function* () {
            const ffmpegContainerId = this.stoppedFfmpegContainer.getId();
            logger_1.log.debug("Extracting archive from container...", { containerId: ffmpegContainerId });
            const archiveStream = yield this.stoppedFfmpegContainer.copyArchiveFromContainer("/videos/video.mp4");
            logger_1.log.debug("Extracted archive from container", { containerId: ffmpegContainerId });
            logger_1.log.debug("Unpacking archive...", { containerId: ffmpegContainerId });
            const destinationDir = tmp_1.default.dirSync({ keep: false });
            yield this.extractTarStreamToDest(archiveStream, destinationDir.name);
            logger_1.log.debug("Unpacked archive", { containerId: ffmpegContainerId });
            const videoFile = path_1.default.resolve(destinationDir.name, "video.mp4");
            yield (0, promises_1.copyFile)(videoFile, target);
            logger_1.log.debug(`Extracted video to "${target}"`, { containerId: ffmpegContainerId });
        });
    }
    extractTarStreamToDest(tarStream, dest) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => {
                const destination = tar_fs_1.default.extract(dest);
                tarStream.pipe(destination);
                destination.on("finish", resolve);
            });
        });
    }
}
exports.StoppedSeleniumRecordingContainer = StoppedSeleniumRecordingContainer;
